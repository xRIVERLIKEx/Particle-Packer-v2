<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Particle Pack Generator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load JSZip library for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* NEW CSS for the background */
        body {
            /* FIXED: Added ./ to the URL */
            background-image: url('./ParticleBG.gif');
            background-attachment: fixed; /* Makes it not scroll */
            background-size: cover; /* Stretches to fill the screen */
            background-position: center;
        }

        /* Custom styles for dark mode file inputs */
        input[type="file"]::file-selector-button {
            background-color: #4A5568; /* gray-600 */
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            cursor: pointer;
            transition: background-color 0.2s;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #2D3748; /* gray-700 */
        }
    </style>
</head>
<body class="text-white font-sans p-6 md:p-12"> <!-- Removed bg-gray-900 from class list -->

    <!-- Added transparency and backdrop blur to see the background through the card -->
    <div class="max-w-3xl mx-auto bg-gray-800/80 backdrop-blur-md rounded-2xl shadow-2xl p-8 md:p-10">
        
        <header class="text-center mb-8">
            <!-- ADDED IMAGE HERE -->
            <!-- FIXED: Added ./ to the src -->
            <img src="./Cleverlike School Header Image.png" alt="Cleverlike School Header" class="mx-auto mb-6" style="max-height: 90px;">
            
            <h1 class="text-4xl font-bold text-green-400 mb-2">Particle Pack Generator</h1>
            <p class="text-xl text-gray-300">For Minecraft Bedrock & Education</p>
        </header>

        <!-- Main Form -->
        <div class="space-y-8">

            <!-- Step 1: Pack Details -->
            <section id="step-1" class="space-y-4">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2">Step 1: Pack Details</h2>
                <div>
                    <label for="pack-name" class="block text-sm font-medium text-gray-300 mb-2">Pack Name</label>
                    <input type="text" id="pack-name" placeholder="e.g., My Awesome Particles" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </div>
                <div>
                    <label for="pack-desc" class="block text-sm font-medium text-gray-300 mb-2">Pack Description</label>
                    <input type="text" id="pack-desc" placeholder="A pack full of awesome particles" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </div>
                <!-- New Pack Icon Uploader -->
                <div>
                    <label for="pack-icon" class="block text-sm font-medium text-gray-300 mb-2">Pack Icon (Optional)</label>
                    <input type="file" id="pack-icon" accept="image/png" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3">
                    <p id="pack-icon-feedback" class="text-sm text-green-400 mt-2 hidden"></p>
                </div>
            </section>

            <!-- REMOVED Step 2: Utility Wands -->

            <!-- List of Added Particles -->
            <section id="particle-list-section" class="hidden">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2 mb-4">Added Particles</h2>
                <div id="particle-list-container" class="space-y-2 bg-gray-700 p-4 rounded-lg">
                    <!-- Added particles will be listed here -->
                </div>
            </section>

            <!-- Step 2: Snowstorm File (Was Step 3) -->
            <section id="step-2-json" class="space-y-4">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2">Step 2: Upload Snowstorm .json File</h2>
                <div>
                    <label for="json-file-input" class="block text-sm font-medium text-gray-300 mb-2">Select your particle's .json file:</label>
                    <input type="file" id="json-file-input" accept=".json" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-3">
                </div>
            </section>

            <!-- Step 3: Textures (Was Step 4) -->
            <section id="step-3-textures" class="hidden space-y-6">
                <h2 class="text-2xl font-semibold border-b-2 border-gray-700 pb-2">Step 3: Upload Textures</h2>
                
                <!-- Particle Textures -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-200">Particle Textures</h3>
                    <p class="text-gray-400">The app detected the following textures are needed for the particle itself.</p>
                    <div id="texture-uploads-container" class="space-y-5 bg-gray-700 p-6 rounded-lg mt-3">
                        <!-- Texture inputs will be added here by JS -->
                    </div>
                </div>

                <!-- NEW Wand Texture -->
                <div>
                    <h3 class="text-lg font-semibold text-gray-200">Wand Item Texture</h3>
                    <p class="text-gray-400">Select a texture for the new "Wand" item that will spawn this particle.</p>
                    <!-- REPLACED file input with this selection grid -->
                    <div class="bg-gray-700 p-6 rounded-lg mt-3">
                        <div id="wand-selection-container" class="grid grid-cols-4 sm:grid-cols-7 gap-3">
                            <!-- Wand selection buttons will be dynamically inserted here by JS -->
                        </div>
                        <p id="current-wand-feedback" class="text-sm text-green-400 mt-4 text-center hidden"></p>
                    </div>
                </div>
            </section>

            <!-- Step 4: Add Particle Button (Was Step 5) -->
            <section id="step-add-particle" class="hidden">
                <button id="add-particle-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white text-lg font-bold py-3 px-6 rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                    Add Particle to Pack
                </button>
            </section>

            <!-- Step 5: Generate (Was Step 6) -->
            <section id="step-generate" class="hidden">
                <button id="generate-button" class="w-full bg-green-600 hover:bg-green-700 text-white text-xl font-bold py-4 px-6 rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105">
                    Generate Addon (.mcaddon)
                </button>
                <div id="error-message" class="text-red-400 text-center mt-4 font-medium"></div>
            </section>

            <!-- Step 6: Download & Command (Was Step 7) -->
            <section id="step-download" class="hidden space-y-6 text-center">
                <h2 class="text-3xl font-semibold text-green-400">Addon Generated Successfully!</h2>
                <p class="text-gray-300">Download the <span class="font-bold">.mcaddon</span> file and open it with Minecraft. It will install *both* the Behavior Pack and Resource Pack. Make sure to activate *both* packs on your world.</p>
                
                <!-- Download Button -->
                <div>
                    <a id="download-link" class="inline-block bg-blue-600 hover:bg-blue-700 text-white text-xl font-bold py-4 px-8 rounded-lg shadow-lg transition-transform duration-200 transform hover:scale-105">
                        Download .mcaddon
                    </a>
                </div>

                <!-- Command Output -->
                <div>
                    <h3 classs="text-xl font-semibold mb-2">Your Wand Commands:</h3>
                    <p class="text-gray-400 mb-2">Use these commands in-game to get your wands. Click to copy.</p>
                    <!-- Updated Command Output Styling -->
                    <div class="bg-gray-900 rounded-lg p-4 text-left relative">
                        <pre><code id="command-text" class="text-green-300 whitespace-pre-wrap font-mono"></code></pre>
                        <button id="copy-button" title="Copy to clipboard" class="absolute top-3 right-3 bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded-md text-sm font-medium transition">
                            Copy
                        </button>
                    </div>
                </div>
            </section>

        </div>
    </div>

    <script type="module">
        // --- Global State ---
        let particleQueue = []; // Stores all added particle data
        let allUploadedTextures = new Map(); // Global map of "textures/particles/path.png" -> File object
        let allUploadedWandTextures = new Map(); // Global map of "textures/items/wand.png" -> File object
        let packIconFile = null; // To store the optional pack_icon.png
        let clearWandTextureFile = null; // This will be auto-populated

        // --- Current Particle State (Temporary) ---
        let currentJson = null;
        let currentOriginalFileName = 'particle.json';
        let currentIdentifier = 'cleverlike:particle';
        let currentRequiredTextures = new Set();
        let currentNewTexturesToUpload = new Set();
        let currentWandTextureFile = null; // The File object for the wand

        // --- NEW: Map to store built-in wand data ---
        const builtInWandBlobs = new Map();

        // --- NEW: Define the wand filenames and their IDs ---
        // FIXED: Added ./ to all file paths
        const wandFiles = new Map([
            ['wand_yellow', './wand.png'],
            ['wand_red', './wand2.png'],
            ['wand_orange', './wand3.png'],
            ['wand_green', './wand4.png'],
            ['wand_cyan', './wand5.png'],
            ['wand_purple', './wand6.png'],
            ['wand_pink', './wand7.png'],
            ['clearwand', './clearwand.png']
        ]);

        // --- DOM Elements ---
        const packNameInput = document.getElementById('pack-name');
        const packDescInput = document.getElementById('pack-desc');
        const packIconInput = document.getElementById('pack-icon'); // Icon input
        const packIconFeedback = document.getElementById('pack-icon-feedback'); // Icon feedback
        const jsonFileInput = document.getElementById('json-file-input');
        
        const particleListSection = document.getElementById('particle-list-section');
        const particleListContainer = document.getElementById('particle-list-container');
        
        const step2Section = document.getElementById('step-2-json'); // Renamed
        const step3Section = document.getElementById('step-3-textures'); // Renamed
        const textureUploadsContainer = document.getElementById('texture-uploads-container');
        const wandSelectionContainer = document.getElementById('wand-selection-container'); // NEW
        const currentWandFeedback = document.getElementById('current-wand-feedback');
        
        const stepAddParticle = document.getElementById('step-add-particle');
        const addParticleButton = document.getElementById('add-particle-button');
        
        const stepGenerate = document.getElementById('step-generate');
        const generateButton = document.getElementById('generate-button');
        const errorMessage = document.getElementById('error-message');
        
        const stepDownload = document.getElementById('step-download');
        const downloadLink = document.getElementById('download-link');
        const commandText = document.getElementById('command-text');
        const copyButton = document.getElementById('copy-button');

        // --- Helper Functions ---
        
        /**
         * Generates a random UUID.
         * Required for all manifest.json files.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Stores the uploaded pack icon file.
         */
        function handlePackIconUpload(event) {
            const file = event.target.files[0];
            if (file) {
                packIconFile = file;
                packIconFeedback.textContent = `✅ Icon selected: ${file.name}`;
                packIconFeedback.classList.remove('hidden');
            }
        }


        /**
         * Displays an error message to the user.
         */
        function showError(message) {
            errorMessage.textContent = message;
            // Clear the error after 5 seconds
            setTimeout(() => {
                errorMessage.textContent = '';
            }, 5000);
        }

        /**
         * Checks if the *current* particle is valid and ready to be added.
         */
        function validateCurrentParticleState() {
            const jsonValid = currentJson !== null;
            const wandTextureValid = currentWandTextureFile !== null;
            
            // Check if all *new* textures for *this* particle are uploaded
            let newTexturesReady = true;
            if (currentNewTexturesToUpload.size > 0) {
                for (let path of currentNewTexturesToUpload) {
                    // Check if it's in the *global* map (meaning it was uploaded)
                    if (!allUploadedTextures.has(path)) {
                        newTexturesReady = false;
                        break;
                    }
                }
            }

            if (jsonValid && newTexturesReady && wandTextureValid) {
                addParticleButton.disabled = false;
                errorMessage.textContent = '';
                stepAddParticle.classList.remove('hidden');
            } else {
                addParticleButton.disabled = true;
                stepAddParticle.classList.add('hidden');
            }
        }

        /**
         * Checks if the *entire pack* is valid and ready to generate.
         */
        function validatePackState() {
            const nameValid = packNameInput.value.trim() !== '';
            const descValid = packDescInput.value.trim() !== '';
            const particlesAdded = particleQueue.length > 0;

            if (nameValid && descValid && particlesAdded) {
                stepGenerate.classList.remove('hidden');
            } else {
                stepGenerate.classList.add('hidden');
            }
        }


        /**
         * Handles the .json file upload.
         */
        function handleJsonFile(event) {
            const file = event.target.files[0];
            if (!file) {
                resetCurrentParticle();
                return;
            }

            currentOriginalFileName = file.name;
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const jsonString = e.target.result;
                    let tempJson = JSON.parse(jsonString); // Parse once to validate
                    
                    if (!tempJson.particle_effect || !tempJson.particle_effect.description) {
                        throw new Error("This doesn't look like a valid Snowstorm JSON file.");
                    }

                    currentIdentifier = tempJson.particle_effect.description.identifier;
                    if (!currentIdentifier || !currentIdentifier.includes(':')) {
                        throw new Error("JSON must have a valid 'identifier' (e.g., 'namespace:particle_name').");
                    }
                    
                    // --- NEW LOGIC: Unique Texture Renaming ---
                    const particlePrefix = currentOriginalFileName
                        .replace(/.json$/i, '')
                        .replace(/[^a-z0-9]/gi, '_'); // FIXED: Was [^a-z0-0]

                    const regex = /"(textures\/.*?)"/g;
                    const matches = [...jsonString.matchAll(regex)].map(m => m[1]);
                    const originalPaths = new Set(matches);

                    let modifiedJsonString = jsonString;
                    currentRequiredTextures.clear(); 

                    originalPaths.forEach(originalPath => {
                        const pathParts = originalPath.split('/');
                        const fileName = pathParts.pop();
                        const newFileName = `${particlePrefix}_${fileName}`; 
                        const newPath = `textures/particles/${newFileName}`; 
                        
                        currentRequiredTextures.add(newPath);
                        modifiedJsonString = modifiedJsonString.replace(new RegExp(`"${originalPath}"`, 'g'), `"${newPath}"`);
                    });

                    currentJson = JSON.parse(modifiedJsonString);
                    // --- END NEW LOGIC ---

                    currentNewTexturesToUpload.clear();
                    currentRequiredTextures.forEach(path => {
                        if (!allUploadedTextures.has(path)) {
                            currentNewTexturesToUpload.add(path);
                        }
                    });

                    renderTextureInputs();
                    step3Section.classList.remove('hidden');
                    validateCurrentParticleState();

                } catch (err) {
                    showError(`Error processing JSON: ${err.message}`);
                    resetCurrentParticle();
                }
            };

            reader.onerror = () => {
                showError("Failed to read the file.");
                resetCurrentParticle();
            };

            reader.readAsText(file);
        }

        /**
         * Creates and displays file input fields for *only* new, un-uploaded textures.
         */
        function renderTextureInputs() {
            textureUploadsContainer.innerHTML = '';
            
            if (currentNewTexturesToUpload.size === 0 && currentJson) {
                textureUploadsContainer.innerHTML = '<p class="text-gray-300 font-medium text-center">This particle uses textures you have already provided.</p>';
            } else if (currentNewTexturesToUpload.size > 0) {
                currentNewTexturesToUpload.forEach(path => {
                    const inputId = `texture-input-${path.replace(/[^a-z0-9]/gi, '-')}`;
                    
                    const container = document.createElement('div');
                    container.className = "border-b border-gray-600 pb-4";
                    
                    const label = document.createElement('label');
                    label.htmlFor = inputId;
                    label.className = "block text-sm font-medium text-gray-300 mb-2";
                    label.textContent = `Required Path: ${path}`;
                    
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.id = inputId;
                    input.accept = 'image/png';
                    input.className = "w-full bg-gray-600 border border-gray-500 rounded-lg p-2";
                    
                    input.dataset.path = path; 
                    
                    input.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            allUploadedTextures.set(path, file);
                            label.textContent = `✅ ${path} (Uploaded: ${file.name})`;
                            label.classList.add('text-green-400');
                            currentNewTexturesToUpload.delete(path);
                        } else {
                            allUploadedTextures.delete(path);
                            label.textContent = `Required Path: ${path}`;
                            label.classList.remove('text-green-400');
                            currentNewTexturesToUpload.add(path);
                        }
                        validateCurrentParticleState();
                    });
                    
                    container.appendChild(label);
                    container.appendChild(input);
                    textureUploadsContainer.appendChild(container);
                });
            }
        }


        /**
         * NEW: Handles the user clicking a wand from the selection grid.
         */
        function handleWandSelection(event) {
            const selectedButton = event.currentTarget;
            const wandId = selectedButton.dataset.wandId;

            const allButtons = wandSelectionContainer.querySelectorAll('button');
            allButtons.forEach(btn => btn.classList.remove('border-blue-500', 'ring-2', 'ring-blue-500'));
            selectedButton.classList.add('border-blue-500', 'ring-2', 'ring-blue-500');

            currentWandTextureFile = builtInWandBlobs.get(wandId);

            currentWandFeedback.textContent = `✅ ${wandId} selected.`;
            currentWandFeedback.classList.remove('hidden');

            validateCurrentParticleState();
        }

        /**
         * Resets the "current particle" UI to add another one.
         */
        function resetCurrentParticle() {
            currentJson = null;
            currentOriginalFileName = 'particle.json';
            currentIdentifier = 'cleverlike:particle';
            currentRequiredTextures.clear();
            currentNewTexturesToUpload.clear();
            currentWandTextureFile = null;

            jsonFileInput.value = '';
            step3Section.classList.add('hidden');
            textureUploadsContainer.innerHTML = '';
            currentWandFeedback.classList.add('hidden');

            const allButtons = wandSelectionContainer.querySelectorAll('button');
            allButtons.forEach(btn => btn.classList.remove('border-blue-500', 'ring-2', 'ring-blue-500'));
            
            stepAddParticle.classList.add('hidden');
            addParticleButton.disabled = true;
        }

        /**
         * Updates the list of added particles in the UI.
         */
        function updateParticleListUI() {
            particleListContainer.innerHTML = '';
            if (particleQueue.length === 0) {
                particleListSection.classList.add('hidden');
                return;
            }

            particleQueue.forEach((particle, index) => {
                const item = document.createElement('p');
                item.className = "text-green-300";
                item.textContent = `Particle ${index + 1}: ${particle.identifier} (from ${particle.originalFileName})`;
                particleListContainer.appendChild(item);
            });
            particleListSection.classList.remove('hidden');
        }

        /**
         * Adds the fully-defined "current" particle to the main pack queue.
         */
        function handleAddParticleClick() {
            if (addParticleButton.disabled || !currentJson || !currentWandTextureFile) return;

            const wandTextureName = currentIdentifier.split(':')[1] + '_wand';
            const wandTexturePath = `textures/items/${wandTextureName}.png`;
            allUploadedWandTextures.set(wandTexturePath, currentWandTextureFile);
            
            const anchorId = `${currentIdentifier}_anchor`;

            particleQueue.push({
                json: currentJson,
                originalFileName: currentOriginalFileName,
                identifier: currentIdentifier,
                wandTexturePath: wandTexturePath,
                wandTextureShortName: wandTextureName,
                anchorId: anchorId
            });

            updateParticleListUI();
            resetCurrentParticle();
            validatePackState();
        }

        /**
         * Creates a Behavior Pack manifest.json file content.
         * FIXED: Updated type from "data" to "script"
         */
        function createBPManifest(name, desc, bp_uuid, bp_module_uuid, rp_uuid) {
            return {
                "format_version": 2,
                "header": {
                    "name": `${name} (Behaviors)`,
                    "description": desc,
                    "uuid": bp_uuid,
                    "version": [1, 0, 0],
                    "min_engine_version": [1, 21, 0]
                },
                "modules": [
                    {
                        // *** THIS IS THE FIX: "script" tells the game to load items/functions ***
                        "type": "script", 
                        "uuid": bp_module_uuid,
                        "version": [1, 0, 0]
                    }
                ],
                "dependencies": [
                    {
                        "uuid": rp_uuid,
                        "version": [1, 0, 0]
                    }
                ]
            };
        }

        /**
         * Creates a Resource Pack manifest.json file content.
         */
        function createRPManifest(name, desc, rp_uuid, rp_module_uuid) {
            return {
                "format_version": 2,
                "header": {
                    "name": `${name} (Resources)`,
                    "description": desc,
                    "uuid": rp_uuid,
                    "version": [1, 0, 0],
                    "min_engine_version": [1, 21, 0]
                },
                "modules": [
                    {
                        "type": "resources",
                        "uuid": rp_module_uuid,
                        "version": [1, 0, 0]
                    }
                ]
            };
        }

        /**
         * Creates the JSON for a wand's BEHAVIOR file.
         */
        function createWandItemBP(id, eventName) {
            return {
                "format_version": "1.19.0",
                "minecraft:item": {
                    "description": {
                        "identifier": id,
                        "category": "equipment",
                        "menu_category": {
                            "category": "equipment",
                            "group": "itemGroup.name.wand"
                        }
                    },
                    "components": {
                        "minecraft:max_stack_size": 1,
                        "minecraft:on_use": {
                            "on_use": {
                                "event": eventName,
                                "target": "self"
                            }
                        },
                        "minecraft:cooldown": {
                            "category": "wand",
                            "duration": 0.5
                        }
                    },
                    "events": {
                        [eventName]: {
                            "run_command": {
                                "command": []
                            }
                        }
                    }
                }
            };
        }

        /**
         * Creates the JSON for a wand's RESOURCE file.
         */
        function createWandItemRP(id, textureShortName) {
            return {
                "format_version": "1.19.0",
                "minecraft:item": {
                    "description": {
                        "identifier": id,
                        "category": "equipment"
                    },
                    "components": {
                        "minecraft:icon": {
                            "texture": textureShortName
                        },
                        "minecraft:render_offsets": "tools",
                        "minecraft:hand_equipped": true
                    }
                }
            };
        }
        
        /**
         * NEW: Creates the JSON for a particle anchor (BP).
         */
        function createParticleAnchorBP(anchorId, particleId) {
            return {
                "format_version": "1.19.0",
                "minecraft:entity": {
                    "description": {
                        "identifier": anchorId,
                        "is_spawnable": false,
                        "is_summonable": true,
                        "is_experimental": false
                    },
                    "components": {
                        "minecraft:type_family": { "family": [ "particle_anchor", "inanimate" ] },
                        "minecraft:persistent": {},
                        "minecraft:physics": { "has_gravity": false, "has_collision": false },
                        "minecraft:pushable": { "is_pushable": false },
                        "minecraft:tick_world": {
                            "distance_to_players": 32,
                            "interval": 2
                        },
                        "minecraft:behavior.tick_world": {
                            "priority": 1,
                            "on_tick": {
                                "event": "spawn_particle"
                            }
                        }
                    },
                    "events": {
                        "spawn_particle": {
                            "run_command": {
                                "command": [
                                    `particle ${particleId} ~ ~ ~`
                                ]
                            }
                        }
                    }
                }
            };
        }

        /**
         * NEW: Creates the JSON for a particle anchor (RP), making it invisible.
         */
        function createParticleAnchorRP(anchorId) {
            return {
                "format_version": "1.18.0",
                "minecraft:client_entity": {
                    "description": {
                        "identifier": anchorId,
                        "materials": { "default": "entity_alphatest" },
                        "textures": {},
                        "geometry": {},
                        "render_controllers": [ "controller.render.invisible" ]
                    }
                }
            };
        }

        /**
         * Main function to generate the .mcpack file.
         */
        async function handleGenerateClick() {
            if (particleQueue.length === 0) {
                showError("Please add at least one particle.");
                return;
            }
            if (packNameInput.value.trim() === '' || packDescInput.value.trim() === '') {
                showError("Please provide a Pack Name and Description.");
                return;
            }

            try {
                const bp_zip = new JSZip();
                const rp_zip = new JSZip();
                const addon_zip = new JSZip();

                const packName = packNameInput.value.trim();
                const packDesc = packDescInput.value.trim();
                const safeFileName = packName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const namespace = "cleverlike";

                const bp_uuid = generateUUID();
                const rp_uuid = generateUUID();
                const bp_module_uuid = generateUUID();
                const rp_module_uuid = generateUUID();

                const bpManifest = createBPManifest(packName, packDesc, bp_uuid, bp_module_uuid, rp_uuid);
                const rpManifest = createRPManifest(packName, packDesc, rp_uuid, rp_module_uuid);
                bp_zip.file("manifest.json", JSON.stringify(bpManifest, null, 2));
                rp_zip.file("manifest.json", JSON.stringify(rpManifest, null, 2));

                let langFileContent = "## Cleverlike Particle Wands\n";
                langFileContent += "itemGroup.name.wand=Particle Wands\n"; 
                
                let itemTextureJson = { "resource_pack_name": "cleverlike_items", "texture_data": {} };
                let particleTextureJson = { "resource_pack_name": "cleverlike_particles", "texture_data": {} };
                
                if (packIconFile) {
                    rp_zip.file("pack_icon.png", packIconFile);
                    bp_zip.file("pack_icon.png", packIconFile);
                }
                
                const invisibleController = { "format_version": "1.10.0", "render_controllers": { "controller.render.invisible": { "geometry": "Geometry.default", "materials": [], "textures": [] } } };
                rp_zip.file("render_controllers/invisible.json", JSON.stringify(invisibleController, null, 2));


                // --- Process CLEAR WAND (Hardcoded) ---
                const clearWandId = `${namespace}:clear_wand`;
                const clearWandShortName = "clear_wand";
                
                let clearWandBP = createWandItemBP(clearWandId, "cleverlike:clear");
                clearWandBP["minecraft:item"].events["cleverlike:clear"].run_command.command = [
                    "function clear_particles"
                ];
                bp_zip.file("items/clear_wand.json", JSON.stringify(clearWandBP, null, 2));
                
                // FIXED: This function content ONLY contains kill commands.
                let clearFunction = `## Clears all particle anchors in a 3-block radius\n`;
                
                const clearWandRP = createWandItemRP(clearWandId, clearWandShortName);
                rp_zip.file("items/clear_wand.json", JSON.stringify(clearWandRP, null, 2));
                
                rp_zip.file(`textures/items/${clearWandShortName}.png`, clearWandTextureFile);
                itemTextureJson.texture_data[clearWandShortName] = { "textures": `textures/items/${clearWandShortName}` };
                
                langFileContent += `item.${clearWandId}.name=Clear Wand\n`;
                
                // This "empty" particle is no longer needed by the function,
                // but we can leave it in case users want to reference it.
                const emptyParticle = { "format_version": "1.10.0", "particle_effect": { "description": { "identifier": `${namespace}:empty`, "basic_render_parameters": { "material": "particles_alpha", "texture": "textures/particle/particles" } }, "components": {} } };
                rp_zip.file("particles/empty.json", JSON.stringify(emptyParticle, null, 2));


                // --- Loop through queued particles ---
                for (const particle of particleQueue) {
                    const wandId = `${particle.identifier}_wand`;
                    const wandShortName = particle.wandTextureShortName;
                    const particleId = particle.identifier;
                    const particleFileName = particle.originalFileName;
                    const wandTexturePath = particle.wandTexturePath;
                    const wandFile = allUploadedWandTextures.get(wandTexturePath);
                    const anchorId = particle.anchorId;
                    const anchorFileName = `${wandShortName}_anchor`;

                    // BP: Create item JSON
                    let wandBP = createWandItemBP(wandId, "cleverlike:spawn");
                    wandBP["minecraft:item"].events["cleverlike:spawn"].run_command.command = [
                        `summon ${anchorId} ~ ~1 ~`
                    ];
                    bp_zip.file(`items/${wandShortName}.json`, JSON.stringify(wandBP, null, 2));

                    // BP: Create anchor entity file
                    const anchorBP = createParticleAnchorBP(anchorId, particleId);
                    bp_zip.file(`entities/${anchorFileName}.json`, JSON.stringify(anchorBP, null, 2));

                    // RP: Create item JSON
                    const wandRP = createWandItemRP(wandId, wandShortName);
                    rp_zip.file(`items/${wandShortName}.json`, JSON.stringify(wandRP, null, 2));

                    // RP: Create anchor entity file
                    const anchorRP = createParticleAnchorRP(anchorId);
                    rp_zip.file(`entities/${anchorFileName}.json`, JSON.stringify(anchorRP, null, 2));

                    // RP: Add wand texture
                    rp_zip.file(wandTexturePath, wandFile);
                    itemTextureJson.texture_data[wandShortName] = { "textures": `textures/items/${wandShortName}` };

                    // RP: Add particle JSON
                    rp_zip.file(`particles/${particleFileName}`, JSON.stringify(particle.json, null, 2));

                    // RP: Add lang entry
                    let niceName = wandShortName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    langFileContent += `item.${wandId}.name=${niceName}\n`;
                    
                    // BP: Add to the clear wand's function
                    clearFunction += `kill @e[type=${anchorId}, r=3]\n`;
                }
                
                // --- Add all unique, uploaded PARTICLE textures ---
                for (const [path, file] of allUploadedTextures.entries()) {
                    rp_zip.file(path, file);
                    const shortPath = path.replace('textures/', '').replace('.png', '');
                    particleTextureJson.texture_data[shortPath] = { "textures": path };
                }

                // --- Add mapping files and lang file ---
                bp_zip.file("functions/clear_particles.mcfunction", clearFunction);
                rp_zip.file("texts/en_US.lang", langFileContent);
                rp_zip.file("textures/item_texture.json", JSON.stringify(itemTextureJson, null, 2));
                rp_zip.file("textures/particle_texture.json", JSON.stringify(particleTextureJson, null, 2));

                // --- Generate Blobs and Final .mcaddon ---
                const bp_blob = await bp_zip.generateAsync({ type: "blob" });
                const rp_blob = await rp_zip.generateAsync({ type: "blob" });

                addon_zip.file(`${safeFileName}_BP.mcpack`, bp_blob);
                addon_zip.file(`${safeFileName}_RP.mcpack`, rp_blob);

                const addon_blob = await addon_zip.generateAsync({ type: "blob" });
                
                const url = URL.createObjectURL(addon_blob);
                downloadLink.href = url;
                downloadLink.download = `${safeFileName}.mcaddon`;
                
                let commands = `## Give commands for your wands:\n/give @s ${clearWandId}\n`;
                commands += particleQueue.map(p => `/give @s ${p.identifier}_wand`).join('\n');
                commandText.textContent = commands;
                
                stepDownload.classList.remove('hidden');

            } catch (err) {
                showError(`Failed to generate pack: ${err.message}`);
                console.error(err);
            }
        }
        
        /**
         * Copies the generated command to the clipboard.
         */
        function copyCommandToClipboard() {
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = commandText.textContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            try {
                document.execCommand('copy');
                copyButton.textContent = 'Copied!';
                setTimeout(() => { copyButton.textContent = 'Copy'; }, 2000);
            } catch (err) {
                showError('Failed to copy commands.');
            }
            document.body.removeChild(tempTextArea);
        }

        // --- Event Listeners ---
        jsonFileInput.addEventListener('change', handleJsonFile);
        packNameInput.addEventListener('input', validatePackState);
        packDescInput.addEventListener('input', validatePackState);
        packIconInput.addEventListener('change', handlePackIconUpload);
        
        addParticleButton.addEventListener('click', handleAddParticleClick);
        generateButton.addEventListener('click', handleGenerateClick);
        copyButton.addEventListener('click', copyCommandToClipboard);

        // --- Page Initialization ---
        
        /**
         * NEW: Creates the wand selection buttons from the fetched image paths.
         */
        function renderWandSelector() {
            wandSelectionContainer.innerHTML = '';
            
            for (const [id, filename] of wandFiles.entries()) {
                if (id === 'clearwand') continue;

                const button = document.createElement('button');
                button.type = 'button';
                button.dataset.wandId = id;
                button.className = "bg-gray-600 rounded-lg p-2 border-2 border-transparent transition-all duration-150 hover:bg-gray-500 focus:outline-none";
                button.title = `${id} wand`;
                
                const img = document.createElement('img');
                // FIXED: Use the resolved URL
                img.src = new URL(filename, document.baseURI).href;
                img.alt = `${id} wand texture`;
                img.className = "w-full h-auto object-contain";
                
                button.appendChild(img);
                button.addEventListener('click', handleWandSelection);
                wandSelectionContainer.appendChild(button);
            }
        }

        /**
         * Initializes the app on load.
         */
        async function init() {
            try {
                for (const [id, filename] of wandFiles.entries()) {
                    // FIXED: Resolve the URL properly
                    const resolvedUrl = new URL(filename, document.baseURI).href;
                    const response = await fetch(resolvedUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${filename} (from ${resolvedUrl})`);
                    }
                    const blob = await response.blob();
                    builtInWandBlobs.set(id, blob);
                }
                
                clearWandTextureFile = builtInWandBlobs.get('clearwand');

            } catch (e) {
                console.error("Failed to load built-in wand textures:", e);
                showError(`Error: Failed to load wand images. Make sure all wand.png files are uploaded to GitHub. [${e.message}]`);
            }

            renderWandSelector();
            validatePackState();
            validateCurrentParticleState();
        }

        // Run init on page load
        init();

    </script>
</body>
</html>
